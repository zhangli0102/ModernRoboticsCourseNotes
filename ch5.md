---
layout: post
mathjax: true
title: 'Chapter 5: Velocity Kinematics and Statics'
description: Modern Robotics Course Notes
is_project_page: false
---

<p style="text-align:center;">
<button type="button" onclick="window.location.href='index.html';">Homepage</button>
<span style="float:left;"><button type="button" onclick="window.location.href='ch4.html';">Previous</button></span>
<span style="float:right;"><button type="button" onclick="window.location.href='ch6.html';">Next</button></span>
</p>

## Introduction {#introduction}

### Jacobian Matrices
Here we introduce the concept of **Jacobian** matrix. To help understand, the end-effector configuration is represented by a minimal set of parameters as: $x(t)$, which is the function of time $t$. Based on the forward kinematics introduced in the last chapter, this configuration can be calculated from the set of joint variables:

$$
x(t) = f(\theta(t))
$$

The time derivative of $x$ is named the tip velocity $v_{tip}$, it can be calculated as:

$$
\begin{aligned}
    v_{tip} & = \dot{x} \\
            & = \frac{\partial f(\theta)}{\partial \theta} \frac{d\theta(t)}{dt} \\
            & = J(\theta) \dot{\theta}
\end{aligned}
$$

$J(\theta) \in \mathbb{R}^{m\times n}$ is the Jacobian matrix of $f(\theta) \in \mathbb{R}^m$, where $\theta \in \mathbb{R}^n$. Generally, $J(\theta)$ is defined and arranged as <sup>[1]</sup>:

$$
\begin{aligned}
    J(\theta) & = \left[\begin{matrix} \frac{\partial f}{\partial \theta_1} & \cdots & \frac{\partial f}{\partial \theta_n} \end{matrix}\right] \\
              & = \left[\begin{matrix} \frac{\partial f_1}{\partial \theta_1} & \cdots & \frac{\partial f_1}{\partial \theta_n} \\ \vdots & \ddots & \vdots \\ \frac{\partial f_m}{\partial \theta_1} & \cdots & \frac{\partial f_m}{\partial \theta_n} \\ \end{matrix}\right]
\end{aligned}
$$

#### Several Notes for Jacobian matrices

* If two rows or columns of the Jacobian matrix become aligned, such configurations are called **singularities**, which *are characterized by a situation where the robot tip is unable to generate velocities in certain directions*. 
  * In this case, the Jacobian matrix is a singular matrix, which does not have a *matrix inverse*. *A matrix is singular iff its determinant is 0* <sup>[2]</sup>.

* Column $i$ of the Jacobian corresponds to the end-effector velocity when joint $i$ moves at unit speed and all other joints are stationary.

### Manipulability Ellipsoid

If we limit the joint velocities $\theta_i \in \theta$ in a shpere (or hypersphere if $\theta$ is more than 3 dimensions), Jacobian can map these limits to the limits of tip velocities $\dot{x_i} \in \dot{x}$, which, in general, is an ellipsiod (or hyperellipsoid if \dot{x} is more than 3 dimensions). This ellipsoid is called **manipulability ellipsoid**. A 2R arm example is shown below:

![ch5_f1](https://raw.githubusercontent.com/MuchenSun/ModernRoboticsCourseNotes/master/_img/ch5_f1.png)

Manipulability ellipsoid describes how close a posture is to a singularity. The closer the ellipsoid is to a circle, the more easily the end-effector can move in arbitrary directions. In contrast, when the configuration reaches singularity, the ellipsoid collapses to a line segment, and the volume of the ellipsiod is zero.

### Force Ellipsoid

Jacobian matrices can also be used for static analysis. Assuming the robot is at equilibrium, the power generated by an externel force applied on the tip must be equal to the power generated at the joints. Based on this, we can calculate the joint torque $\tau$ needed to generate the desired tip force $f_{tip}$ by:

$$\tau = J^{T}(\theta) f_{tip}$$

where $J^{T}(\theta)$ is the transpose of the Jacobian matrix.

In the other hand, we can determine the generated tip force with given joint torques by:

$$f_{tip} = J^{-T}(\theta) \tau$$

where $J^{-T}(\theta)$ is the inverse transpose of the Jacobian matrix.

Similarly, if we constrain the joint torque in a shpere (or hypersphere if $\tau$ is more than 3 dimensions), Jacobian(actually the inverse transpose of the Jacobian) can map these limits to the limits of the tip force, which, in general, is a ellipsoid (or hyperellipsoid if $f_{tip}$ is more than 3 dimensions). This ellipsoid is called **force ellipsoid**. 

Unlike manipulability ellipsoid, at a singularity, the force ellipsoid becomes infinitely long and skinny in the othogonal direction to the manipulability ellipsoid (which is a line segment), and its area goes to infinity. This situation means *the end-effector cannot move in one or more directions. Therefore, the robot can resist arbitrary forces trying to move it in one of these directions (without applying forces and torques at the joints)* - When carrying something heavy, it's always easier to put the arm straight down!

#### Relationship Between Manipulability Ellipsoid and Force Ellipsoid

*For a given robot configuration, the principle axes of the manipulability ellipsoid and the force ellipsoid are aligned, and the lengths of the principal semi-axes of the force ellipsoid are the reciprocals of the lengths of the principal semi-axes of the manipulability ellipsoid*.

***

## Manipulator Jacobian {#manipulator_jacobian}

Now, consider a more general case of open chains. In the previous chapters we learn to describe rigid-body motions and forces with twists and wrenches, we need to combine Jacobian with these concepts. The idea here is follows the case in [introduction](#introduction): the $i_{th}$ column of the Jacobian matrix represents the twist of the end-effector, when the $i_{th}$ joint's velocity $\dot{\theta}_i = 1$ and all other joints' velocities are zero. Again, depending on the frame we choose to represent, here we have space Jacobian and body Jacobian.

### Space Jacobian

#### Define Space Jacobian By Calculation

Recall that one interpretation of Jacobian is that it relates joint velocity to the motion of end-effector, which is represented by twist for now. Here, joint velocity $\dot{\theta}$ is obtained from: 

$$\dot{T}(\theta_1, \cdots, \theta_n) = [\mathcal{S}_1]\dot{\theta}_1 e^{[\mathcal{S}_1]\theta_1} \cdots e^{[\mathcal{S}_n]\theta_n} M + e^{[\mathcal{S}_1]\theta_1} [\mathcal{S}_2]\dot{\theta}_2 e^{[\mathcal{S}_2]\theta_2} \cdots e^{[\mathcal{S}_n]\theta_n} M + \cdots$$

and $\dot{\theta}$ can be related to spacial twist $\mathcal{V}_s$ by:

$$
\begin{aligned}
\left[\mathcal{V}_s\right] & = \dot{T}T^{-1} \\
                           & = [\mathcal{S}_1]\dot{\theta}_1 + e^{[\mathcal{S}_1]\theta_1} [\mathcal{S}_2] e^{-[\mathcal{S}_1]\theta_1} \dot{\theta}_2 + e^{[\mathcal{S}_1]\theta_1} e^{[\mathcal{S}_2]\theta_2} [\mathcal{S}_3] e^{-[\mathcal{S}_2]\theta_2} e^{-[\mathcal{S}_1]\theta_1} \dot{\theta}_3 + \cdots
\end{aligned}
$$

this equation also be expressed in vector form by means of adjoint mapping:

$$
\begin{aligned}
\mathcal{V}_s & = \mathcal{S}_1 \dot{\theta}_1 + Ad_{e^{[\mathcal{S}_1]\theta_1}}(\mathcal{S}_2) \dot{\theta}_2 + Ad_{e^{[\mathcal{S}_1]\theta_1} e^{[\mathcal{S}_2]\theta_2}}(\mathcal{S}_3) \dot{\theta}_3 + \cdots \\
              & = J_{s1} \dot{\theta}_1 + J_{s2}(\theta) \dot{\theta}_2 + \cdots + J_{sn}(\theta) \dot{\theta}_n \\
              & = \left[\begin{matrix} J_{s1} & J_{s2}(\theta) & \cdots & J_{sn}(\theta) \end{matrix}\right] \left[\begin{matrix} \dot{\theta}_1 \\ \vdots \\ \dot{\theta}_n \end{matrix}\right] \\
              & = J_s(\theta) \dot{\theta}
\end{aligned}
$$

This equation gives the definition of space Jacobian $J_s$.

#### Define Space Jacobian In Physical World

The $i$th column of the Jacobian describes the screw-axis generated by the $i$th joint. The sum of the products of these screw-axes and related joint velocities is the twist of the end-effector.

Same as the case of forward kinematics, the order of transformations also matters here. For the open-chain structure is no longer constrained at the zero configuration, each joint could be in arbitrary configuration. Thus, the configuration of the $i$th joint is obtained by the transformations of the previous joints from 1 to $i-1$. This explains the formulation of the $i$th column of the Jacobian.

Since we know the physical meaning of space Jacobian, in some case, when the screw-axis of each joint in a structure is obvious, it is more convenient to obtain the entire Jacobian directly. A good example is the *Example 5.3* on page 181 in the textbook.

### Body Jacobian

The definition of body Jacobian (no matter from calculation or physical meaning) is very similar with space Jacobian, please read the text book for details.

Here, the order of transformations also matters. Since the reference frame the body frame, it is natural to see that the configuration of the screw-axis related to joint $i$ is obtained by the transformations from joint $i+1$ to joint $n$.

### Visualizing the Space and Body Jacobian

Well ... I think the way of visualization in both textbook (section 5.3.1) and lecture video is not quite clear, that's why I wrote the section ["Connections Between Chpater 3 and 5"](#summary_35) to show how I understand Jacobian.

### Relationship between the Space and Body Jacobian

Space Jacobian and body Jacobian can be obtained from each other:

$$
J_b(\theta) = [Ad_{T_{bs}}] J_s(\theta) \\
J_s(\theta) = [Ad_{T_{sb}}] J_b(\theta)
$$

### Alternative Notions of the Jacobian

What's the difference between **analytic Jacobian** and **geometric Jacobian**?

*Example 5.5 on page 188* shows an example of analytic Jacobian in the case when a spatial rigid-body in represented by a minimal set of coordinates.

### Looking Ahead to Inverse Velocity Kinematics

Inverse velocity kinemiatcs is the focus of next chapter, it aims to find the joint velocity $\dot{\theta}$ given a desired twist $\mathcal{V}$.

This answer of this question depends on the number of joints $n$ of the Jacobian matrix $J(\theta)$:

* If $n=6$, in other word, if $J(\theta)$ is square, then $\dot{\theta} = J^{-1}(\theta) \mathcal{V}$.
* If $n<6$, then $J(\theta)$ is not invertible.
* If $n>6$, this case is named the robot **redundant**. 
  * > In this case, a desired twist $\mathcal{V}$ places six constraints on the joint rates, and the remaining $n-6$ freedoms correspond to internal motions of the robot that are not evident in the motion of the end-effector.
  * Another good example is the Delta robot mentioned in *example 2.7 on page 22* in the textbook. I also mentioned it in the [course note of chapter 2](ch2.html/#notes_grubler) (see item 4).
  * This explains the first question in the practice quiz of chapter 5.2 and the third question in the practice quiz of chapter 5.3 on Coursera.

***

## Statics of Open Chains

> Power at the joints = (power to move the robot) + (power at the end-effector)

When the robot is at static equilibrium (no power is being used to move the robot), and an external wrench $-\mathcal{F}$ is applied to the end-effector. The robot's joint values are denoted by $\theta$, we have:

$$
\tau = J^T_s(\theta) \mathcal{F}_s = J^T_b(\theta) \mathcal{F}_b
$$

There also exists the opposite question, in which case we are dealing with $J^{-1}(\theta)$ again (Is this straightforward?). Similarly, this answer depends on the number of joints $n$. 

Here is interesting case is when $n<6$.

> If $n\leq6$, no matter what $\tau$ we choose, the robot can not *actively* generate forces in the $6-n$ wrench directions defined bu the null space of $J^T$,
> 
> $$\text{Null}(J^T(\theta)) = \{ \mathcal{F} \mid J^T(\theta) \mathcal{F} = 0 \}$$,
> 
> since no actuators act in these directions. The robot can, however, resist arbitrary externally applied wrenches in the space $\text{Null}(J^T(\theta))$ without moving, owing to the lack of joints that would allow motions due to these forces.

***

## Singularity Analysis

First, let's review the definition of matrix rank:

> The rank of a matrix is defined as (a) the maximum number of linearly independent column vectors in the matrix or (b) the maximum number of linearly independent row vectors in the matrix. Both definitions are equivalent. <sup>[3]</sup>

Twists that can be achieved by the end-effector are linear combinations of the columns of the Jacobian. When one or more columns can be obtained by other columns, the rank will drop, thus the end-effector will lose the ability to generate instantaneous spatial velocities in some directions while gaining the ability to resist arbitrary wrenches in the direction corresponding to the lost mobility.

Recall that kinematic singularity is independent of the choice of the space or body Jacobian and the choice of fixed frame and end-effector frame.

***

## Manipulability

Assuming the joint rates $\dot{\theta} \in \mathbb{R}^n$, which we already know is a vector, can point to any direction in its space, but it's length is constrained by $\Vert\dot{\theta}\Vert = 1$. Then this sub-space of joint rates, which can be visualized as a unit sphere in the $n$-dimensional joint-velocity space, is a perfect tool to measure the manipulability of a given structure.

**Manipulability ellipsiod** is born from this idea. Through Jacobian matrix, the unit sphere in the joint-velocity space can be mapped to an ellipsoid in the task space. Here the dimension of task space can vary, for example, if we are interested in the twist of the end-effector, then the dimension is 6 and the ellipsoid is a six-dimensional hyperellipsoid, if we are interested in the linear velocity of the end-effector, then the manipulability ellipsoid is a three-dimensional ellipsoid.

Recall that we are considering non-singular cases, so the Jacobian matrix is of full rank, thus both $A$ and $A^{-1}$ are square, symmetric, and positive definite.

> ... a **symmetric** matrix is a square matrix that is equal to its transpose. <sup>[4]</sup>
> 
> ... a symmetric $n\times n$ real matrix $M$ is said to be **positive definite** if the scalar $z^T M z$ is strictly positive for every non-zero column vector $z$ of $n$ real numbers. <sup>[5]</sup>

The manipulability ellipsoid can be obtained through Jacobian by the set of $\dot{q} \in \mathbb{R}^m$ that satisfies:

$$
\dot{q}^T A^{-1} \dot{q} = 1
$$

where $A = JJ^T$. The direction and length of the priciple axes of the ellipsoid can be obtained from $A$'s eigenvectors and eigenvalues (**Remember, from $A$, not $A^{-1}!$**).

> ... an **eigenvector** or **characteristic vector** of a linear transformation is a non-zero vector that changes by only a scalar factor when that linear transformation is applied to it. More formally, if $T$ is a linear transformation from a vector space $V$ over a field $F$ into itself and $\mathbf{v}$ is a vector in $V$ that is not the zero vector, then $\mathbf{v}$ is an eigenvector of $T$ if $T(\mathbf{v})$ is scalar multiple of $\mathbf{v}$. This condition can be written as the equation:
> 
> $$T(\mathbf{v}) = \lambda \mathbf{v}$$,
> 
> where $\lambda$ is a scalar in the field $F$, known as the **eigenvalue**, **characteristic value**, or **characteristic root** associated with the eigenvector $\mathbf{v}$. <sup>[6]</sup>

***

## Connections Between Chpater 3 and 5 {#summary_35}

### Angular Velocity and Twist

Let's start with **angular velocity**. It's a vector, its direction is assigned with the rotation axis following the right-hand rule, and its length is the rate of rotation (joint velocity). It's not related to any specific rigid-body, in other words, any rigid-body could be in this state. It doesn't depend on any reference frame, either. It just describes an instant state of motion that something is rotating around a fixed-axis in the space with a fixed rate. To relate angular velocity $\omega_s$ to a rigid-body which can be represented by a rotation matrix $R$, we have:

$$\dot{R} = \omega_s \times R = [\omega_s] R$$

The same idea also exists in **twist**, which is the combination of linear and angular velocities. The purpose of introducing such concept is to describe all motions in space by displacement, which makes **the screw interpretation of twist** straightforward. If you truly understand angular velocity, there should no problem with understanding twist.

### Twist and Velocity Kinematics

The idea of considering twist as an instant state of motion should help to understand the Jacobian matrix in velocity kinematics and many other aspects. 

In velocity kinematics, the target is to describe the motion of end-effector. This motion is highly constrained by joints, which means describing the states of motion at those joint is describing the motion of the end-effector. 

The simplest example is a 1-R arm, the end-effector is rotating around the only joint. The joint, of course, is a specific body, however, the twist generated by the joint is body-free (I invented this word?) and coordinate-free. That's why we can calculate twists from each joint and sum them up as the twist of the end-effector. Expanding it to the case of multiple joints, it is straightforward to see why the screw-axes used in the formulation must be at the zero configuration.

***

## Python Solution for Course Quiz

```python
import math
import numpy as np
from numpy import linalg as LA
import modern_robotics as mr

# global variables
pi = math.pi

# question 1
Fs_1 = np.array([0, 0, 0, 2, 0, 0])  # wrench on the tip
Slist_1 = np.array([[  0,  0,  1,  0,  0,  0],
                    [  0,  0,  1,  0, -1,  0],
                    [  0,  0,  1,  0, -2,  0]]).T
thetalist_1 = np.array([0, pi/4, 0])

Js_1 = mr.JacobianSpace(Slist_1, thetalist_1)
taulist_1 = np.dot(Js_1.T, Fs_1)
taulist_1_off = np.around(taulist_1, decimals=2)

print("\nQuestion 1:\n", np.array2string(taulist_1_off, separator=','))

# question  2
Fb_2 = np.array([  0,  0, 10, 10, 10,  0])
Blist_2 = np.array([[  0,  0,  1,  0,  4,  0],
                    [  0,  0,  1,  0,  3,  0],
                    [  0,  0,  1,  0,  2,  0],
                    [  0,  0,  1,  0,  1,  0]]).T
thetalist_2 = np.array([      0,      0,  pi/2, -pi/2])

Jb_2 = mr.JacobianBody(Blist_2, thetalist_2)
taulist_2 = np.dot(Jb_2.T, Fb_2)
taulist_2_off = np.around(taulist_2, decimals=2)

print("\nQuestion 2:\n", np.array2string(taulist_2_off, separator=','))

# question 3
Slist_3 = np.array([[ 0, 0, 1, 0, 0, 0],
                    [ 1, 0, 0, 0, 2, 0],
                    [ 0, 0, 0, 0, 1, 0]]).T
thetalist_3 = np.array([ pi/2, pi/2,    1])

Js_3 = mr.JacobianSpace(Slist_3, thetalist_3)
Js_3_off = np.around(Js_3, decimals=2)

print("\nQuestion 3:\n", np.array2string(Js_3_off, separator=','))

# question 4
Blist_4 = np.array([[  0,  1,  0,  3,  0,  0],
                    [ -1,  0,  0,  0,  3,  0],
                    [  0,  0,  0,  0,  0,  1]]).T
thetalist_4 = np.array([ pi/2, pi/2,    1])

Jb_4 = mr.JacobianBody(Blist_4, thetalist_4)
Jb_4_off = np.around(Jb_4, decimals=2)

print("\nQuestion 4:\n", np.array2string(Jb_4_off, separator=','))

# question 5
Jb_5 = np.array([[ 0.   ,  0.   ,  1.   , -0.105, -0.889,  0.   ],
                 [-1.   ,  0.   ,  0.   ,  0.   ,  0.006, -0.105],
                 [ 0.   ,  1.   ,  0.   ,  0.006,  0.   ,  0.889],
                 [ 0.   ,  0.   ,  1.   , -0.045, -0.844,  0.   ],
                 [-1.   ,  0.   ,  0.   ,  0.   ,  0.006,  0.   ],
                 [ 0.   ,  1.   ,  0.   ,  0.006,  0.   ,  0.   ],
                 [ 0.   ,  0.   ,  1.   ,  0.   ,  0.   ,  0.   ]]).T
Jv_5 = Jb_5[3:]

A_5 = np.dot(Jv_5, Jv_5.T)
w_5, v_5 = LA.eig(A_5)
maxId_5 = np.where(w_5 == np.amax(w_5))[0][0]

vecPAxis = v_5[maxId_5]
vecPAxis_off = np.around(vecPAxis, decimals=2)
print("\nQuestion 5:\n", np.array2string(vecPAxis_off, separator=','))

# question 6
lenPAxis = math.sqrt(w_5[maxId_5])
lenPAxis_off = np.around(lenPAxis, decimals=2)
print("\nQuestion 6:\n", np.array2string(lenPAxis_off, separator=','))
```

***

## References {#reference}

[1] [Jacobian matrix and determinant (Wikipedia)](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)

[2] [Singular Matrix (Wolfram MathWorld)](http://mathworld.wolfram.com/SingularMatrix.html)

[3] [Matrix Rank (Stat Trek)](https://stattrek.com/matrix-algebra/matrix-rank.aspx )

[4] [Symmetric matrix (Wikipedia)](https://en.wikipedia.org/wiki/Symmetric_matrix)

[5] [Definiteness of a matrix (Wikipedia)](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix)

[6] [Eigenvalues and eigenvectors (Wikipedia)](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors)